[["R-Handbook-for-Epis.html", "R Handbook for Epidemiologists 1 Welcome 1.1 About this handbook 1.2 Acknowledgements 2 Style and editorial notes 2.1 Style 2.2 Editorial decisions 3 Datasets used 4 Cleaning data 4.1 Overview 4.2 Preparation 4.3 Cleaning pipeline 4.4 Column names 4.5 Select or re-order columns 4.6 Modify class 4.7 Add columns and rows 4.8 Recoding values 4.9 Filter rows 4.10 Numeric categories 4.11 rowwise() dplyr() 4.12 Transforming multiple variables at once 4.13 Deduplication 5 Age pyramids 5.1 Overview 5.2 Preparation 5.3 apyramid package 5.4 ggplot() 5.5 Likert scale 5.6 Resources", " R Handbook for Epidemiologists the handbook team 2021-01-24 1 Welcome 1.1 About this handbook Objective A free open-access digital R reference book catered to epidemiologists and public health practitioners that is usable offline and addresses common epidemiological tasks via clear text explanations, step-by-step instructions, and best practice R code examples Epis using R must often Google search and read dozens of forum pages to complete common data manipulation and visualization epi tasks. However, field epidemiologists often work in low internet-connectivity environments and have limited technical support. This handbook aims to fill this gap. How to read this handbook: The is an HTML file which can be viewed offline, and is best viewed with Google Chrome. Search via the search box above the Table of Contents. Ctrl+f will search across the current page. Click the clipboard icon in the upper-right of each code chunk to copy it. Version The latest version of this handbook can be found at this github repository. 1.2 Acknowledgements 1.2.1 Contributors Editor-in-Chief: Neale Batra (neale.batra@gmail.com) Editorial core team:  Authors:  Reviewers:  Advisers  1.2.2 Funding and programmatic support TEPHINET EAN 1.2.3 Data sources outbreaks R package 1.2.4 Inspiration and templates R4Epis RECON packages R4DS book (Hadley) Bookdown book (Yihui) Rmarkdown book (Yihui) 1.2.5 Image credits Logo: CDC Public Image gallery; R Graph Gallery 2 Style and editorial notes 2.1 Style 2.1.1 Text style Package and function names Package names are written in bold (e.g. dplyr) and functions are written like this: mutate(). Packages referenced either in text or within code like this: dplyr::mutate() Types of notes NOTE: This is a note TIP: This is a tip. CAUTION: This is a cautionary note. DANGER: This is a warning. 2.1.2 tidyverse This handbook generally uses tidyverse R coding style. Read more here 2.1.3 Code readability We chose to frequently write code on new lines, in order to offer more understandable comments. As a result, code that could be written like this: obs %&gt;% group_by(name) %&gt;% # group the rows by &#39;name&#39; slice_max(date, n = 1, with_ties = F) # if there&#39;s a tie (of date), take the first row is often written like this: obs %&gt;% group_by(name) %&gt;% # group the rows by &#39;name&#39; slice_max( date, # keep row per group with maximum date value n = 1, # keep only the single highest row with_ties = F) # if there&#39;s a tie (of date), take the first row 2.2 Editorial decisions Below, we track significant editorial decisions around package and function choice. If you disagree or want to offer a new tool, please join/start a conversation on our Github page. Table of package, function, and other editorial decisions Subject Considered Outcome &amp; date Brief rationale Epiweeks aweek, lubridate lubridate, Dec 2020 consistency, package maintenance prospects 3 Datasets used Here the datasets used in this handbook will be described and will be downloadable Linelist () Aggregated case counts () GIS shapefile () modeling dataset? () 4 Cleaning data 4.1 Overview This page demonstrates common steps necessary to clean a dataset. It uses a simulated Ebola case linelist, which is used throughout the handbook. Dealing with character case (upper, lower, title, etc.) Factor columns replace missing with dealing with cases (all lower, etc) case_when() factors 4.2 Preparation 4.2.1 Load packages pacman::p_load(tidyverse, # data manipulation and visualization janitor, # data cleaning rio, # importing data epikit) # age_categories() function 4.2.2 Load data Import the raw dataset using the import() function from the package rio. (LINK HERE TO IMPORT PAGE) ## New names: ## * `` -&gt; ...25 linelist_raw &lt;- import(&quot;linelist_raw.xlsx&quot;) You can view the first 50 rows of the the original raw dataset below: 4.3 Cleaning pipeline In epidemiological analysis and data processing, cleaning steps are often performed together and sequentially. In R this often manifests as a cleaning pipeline, where the raw dataset is passed or piped from one cleaning step to another. The chain utilizes dplyr verbs and the magrittr pipe operator (see handbook page on dplyr and tidyverse coding style (LINK HERE). The pipe begins with the raw data (linelist_raw) and ends with a clean dataset (linelist). In a cleaning pipeline the order of the steps is important. Cleaning steps might include: Importing of data Column names cleaned or changed Rows filtered, added, or de-duplicated Columns selected, added, transformed, or re-ordered Values re-coded, cleaned, or grouped 4.4 Column names Column names are used very often so they need to have clean syntax. We suggest the following: Short names No spaces (replaced with underscores (_), No unusual characters (&amp;, #) Similar style nomenclature (e.g. all date columns named like date_onset, date_report, date_death) The columns names of linelist_raw are below. We can see that there are some with spaces. We also have different naming patterns for dates (date onset and infection date). Also note that in the raw data, the two final columns names were two merged cells with one name. The import() function used the name for the first of the two columns, and assigned the second column the name 23 as it was then empty (referring to the 23rd column). names(linelist_raw) ## [1] &quot;row_num&quot; &quot;case_id&quot; &quot;generation&quot; &quot;infection date&quot; ## [5] &quot;date onset&quot; &quot;hosp date&quot; &quot;date_of_outcome&quot; &quot;outcome&quot; ## [9] &quot;gender&quot; &quot;hospital&quot; &quot;lon&quot; &quot;lat&quot; ## [13] &quot;infector&quot; &quot;source&quot; &quot;age&quot; &quot;ct_blood&quot; ## [17] &quot;age_unit&quot; &quot;fever&quot; &quot;chills&quot; &quot;cough&quot; ## [21] &quot;aches&quot; &quot;vomit&quot; &quot;time_admission&quot; &quot;merged_header&quot; ## [25] &quot;...25&quot; Note: For a column name that include spaces, surround the name with back-ticks, for example: linelist$`infection date`. On a keyboard, the back-tick (`) is different from the single quotation mark (&#39;), and is sometimes on the same key as the tilde (~). 4.4.1 Automatic colummn name cleaning The function clean_names() from the package janitor standardizes column names and makes them unique by doing the following: Converts all names to consist of only underscores, numbers, and letters Accented characters are transliterated to ASCII (e.g. german o with umlaut becomes o, spanish enye becomes n) Capitalization preference can be specified using the case = argument (snake is default, alternatives include sentence, title, small_camel) You can designate specific name replacements with the replace = argument (e.g. replace = c(onset = date_of_onset)) Here is an online vignette Below, the cleaning pipeline begins by using clean_names() on the raw linelist. # send the dataset through the function clean_names() linelist &lt;- linelist_raw %&gt;% janitor::clean_names() # see the new names names(linelist) ## [1] &quot;row_num&quot; &quot;case_id&quot; &quot;generation&quot; &quot;infection_date&quot; ## [5] &quot;date_onset&quot; &quot;hosp_date&quot; &quot;date_of_outcome&quot; &quot;outcome&quot; ## [9] &quot;gender&quot; &quot;hospital&quot; &quot;lon&quot; &quot;lat&quot; ## [13] &quot;infector&quot; &quot;source&quot; &quot;age&quot; &quot;ct_blood&quot; ## [17] &quot;age_unit&quot; &quot;fever&quot; &quot;chills&quot; &quot;cough&quot; ## [21] &quot;aches&quot; &quot;vomit&quot; &quot;time_admission&quot; &quot;merged_header&quot; ## [25] &quot;x25&quot; NOTE: The column name 25 was changed to x25. 4.4.2 Manual column name cleaning Re-naming columns manually is often necessary. Below, re-naming is performed using the rename() function from the dplyr package, as part of a pipe chain. rename() uses the style NEW = OLD, the new column name is given before the old column name. Below, a re-name command is added to the cleaning pipeline: # CLEANING &#39;PIPE&#39; CHAIN (starts with raw data and pipes it through cleaning steps) ################################################################################## linelist &lt;- linelist_raw %&gt;% # standardize column name syntax janitor::clean_names() %&gt;% # manually re-name columns # NEW name # OLD name rename(date_infection = infection_date, date_hospitalisation = hosp_date, date_outcome = date_of_outcome) Now you can see that the columns names have been changed: 4.4.2.1 Rename by column position You can also rename by column position, instead of column name, for example: rename(newNameForFirstColumn = 1, newNameForSecondColumn = 2) 4.4.2.2 Empty Excel column names If you importing an Excel sheet with a missing column name, depending on the import function used, R will likely create a column name with a value like 1 or 2. You can clean these names manually by referencing their position number (see above), or their name (linelist_raw$...1). 4.4.3 Merged Excel column names Merged cells in an Excel file are a common occurrence when receiving data from field level. Merged cells can be nice for human reading of data, but cause many problems for machine reading of data. R cannot accommodate merged cells. Remind people doing data entry that human-readable data is not the same as machine-readable data. Strive to train users about the princiles of tidy data. If at all possible, try to change procedures so that data arrive in a tidy format without merged cells. Each variable must have its own column. Each observation must have its own row. Each value must have its own cell. When using rios import() function, the value in a merged cell will be assigned to the first cell and subsequent cells will be empty. One solution to deal with merged cells is to import the data with the function readWorkbook() from package openxlsx. Set the argument fillMergedCells = TRUE. This gives the value in a merged cell to all cells within the merge range. linelist_raw &lt;- openxlsx::readWorkbook(&quot;linelist_raw.xlsx&quot;, fillMergedCells = TRUE) DANGER: If column names are merged, you will end up with duplicate column names, which you will need to fix manually - R does not work well with duplicate column names! You can re-name them by referencing their position (e.g. column 5), as explained in the section on manual column name cleaning.. 4.4.4 Skip import of rows Sometimes, you may want to avoid importing a row of data (e.g. the column names, which are row 1). you can do this with the argument skip = if using import() from the rio package on a .xlsx or .csv file. Provide the number of rows you want to skip. linelist_raw &lt;- import(&quot;linelist_raw.xlsx&quot;, skip = 1) # does not import header row Unfortunately skip = only accepts one integer value, not a range (e.g. 2:10). To skip import of specific rows that are not consecutive from the top, consider importing multiple times and using bind_rows() from dplyr. See the example below of skipping only row 2. 4.4.4.1 Removing a second header row Your data may have a second row of data, for example if it is a data dictionary row (see example below). This situation can be problematic because it can result in all columns being imported as class character. To solve this, you will likely need to import the data twice. Import the data in order to store the correct column names Import the data again, skipping the first two rows (header and second rows) Bind the correct names onto the reduced dataframe The exact arguments used to bind the correct column names depends on the type of data file (.csv, .tsv, .xlsx, etc.). If using rios import() function, understand which function rio uses to import your data, and then give the appropriate argument to skip lines and/or designate the column names. See the handbook page on importing data (LINK) for details on rio. For Excel files: # For excel files (remove 2nd row) linelist_raw_names &lt;- import(&quot;linelist_raw.xlsx&quot;) %&gt;% names() # save true column names # import, skip row 2, assign to col_names = linelist_raw &lt;- import(&quot;linelist_raw.xlsx&quot;, skip = 2, col_names = linelist_raw_names) For CSV files: # For csv files linelist_raw_names &lt;- import(&quot;linelist_raw.csv&quot;) %&gt;% names() # save true column names # note argument is &#39;col.names =&#39; linelist_raw &lt;- import(&quot;linelist_raw.csv&quot;, skip = 2, col.names = linelist_raw_names) Backup option - changing column names as a separate command # assign/overwrite headers using the base &#39;colnames()&#39; function colnames(linelist_raw) &lt;- linelist_raw_names Bonus! If you do have a second row that is a data dictionary, you can easily create a proper data dictionary from it using the gather() command from the tidyr package. source: https://alison.rbind.io/post/2018-02-23-read-multiple-header-rows/ TO DO library(tidyr) stickers_dict &lt;- import(&quot;linelist_raw.xlsx&quot;) %&gt;% clean_names() %&gt;% gather(variable_name, variable_description) stickers_dict 4.4.5 Combine two header rows In some cases, you may want to combine two header rows into one. This command will define the column names as the combination (pasting together) of the existing column names with the value underneath in the first row. Replace df with the name of your dataset. names(df) &lt;- paste(names(df), df[1, ], sep = &quot;_&quot;) 4.5 Select or re-order columns CAUTION: This tab may follow from previous tabs. Often the first step of cleaning data is selecting the columns you want to work with, and to set their order in the dataframe. In a dplyr chain of verbs, this is done with select(). Note that in these examples we modify linelist with select(), but do not assign/overwrite. We just display the resulting new column names, for purpose of example. CAUTION: In the examples below, linelist is modified with select() but not over-written. New column names are only displayed for purpose of example. Here are all the column names in the linelist: names(linelist) ## [1] &quot;row_num&quot; &quot;case_id&quot; &quot;generation&quot; ## [4] &quot;date_infection&quot; &quot;date_onset&quot; &quot;date_hospitalisation&quot; ## [7] &quot;date_outcome&quot; &quot;outcome&quot; &quot;gender&quot; ## [10] &quot;hospital&quot; &quot;lon&quot; &quot;lat&quot; ## [13] &quot;infector&quot; &quot;source&quot; &quot;age&quot; ## [16] &quot;ct_blood&quot; &quot;age_unit&quot; &quot;fever&quot; ## [19] &quot;chills&quot; &quot;cough&quot; &quot;aches&quot; ## [22] &quot;vomit&quot; &quot;time_admission&quot; &quot;merged_header&quot; ## [25] &quot;x25&quot; 4.5.1 Select &amp; re-order Select only the columns you want to remain, and their order of appearance # linelist dataset is piped through select() command, and names() prints just the column names linelist %&gt;% select(case_id, date_onset, date_hospitalisation, fever) %&gt;% names() # display the column names ## [1] &quot;case_id&quot; &quot;date_onset&quot; &quot;date_hospitalisation&quot; ## [4] &quot;fever&quot; Indicate which columns to remove by placing a minus symbol - in front of the column name (e.g. select(-outcome)), or a vector of column names (as below). All other columns will be retained. Inside select() you can use normal operators such as c() to list several columns, : for consecutive columns, ! for opposite, &amp; for AND, and | for OR. linelist %&gt;% select(-c(date_onset, fever:vomit)) %&gt;% # remove onset and all symptom columns names() ## [1] &quot;row_num&quot; &quot;case_id&quot; &quot;generation&quot; ## [4] &quot;date_infection&quot; &quot;date_hospitalisation&quot; &quot;date_outcome&quot; ## [7] &quot;outcome&quot; &quot;gender&quot; &quot;hospital&quot; ## [10] &quot;lon&quot; &quot;lat&quot; &quot;infector&quot; ## [13] &quot;source&quot; &quot;age&quot; &quot;ct_blood&quot; ## [16] &quot;age_unit&quot; &quot;time_admission&quot; &quot;merged_header&quot; ## [19] &quot;x25&quot; Re-order the columns - use everything() to signify all other columns not specified in the select() command: # move case_id, date_onset, date_hospitalisation, and gender to beginning linelist %&gt;% select(case_id, date_onset, date_hospitalisation, gender, everything()) %&gt;% names() ## [1] &quot;case_id&quot; &quot;date_onset&quot; &quot;date_hospitalisation&quot; ## [4] &quot;gender&quot; &quot;row_num&quot; &quot;generation&quot; ## [7] &quot;date_infection&quot; &quot;date_outcome&quot; &quot;outcome&quot; ## [10] &quot;hospital&quot; &quot;lon&quot; &quot;lat&quot; ## [13] &quot;infector&quot; &quot;source&quot; &quot;age&quot; ## [16] &quot;ct_blood&quot; &quot;age_unit&quot; &quot;fever&quot; ## [19] &quot;chills&quot; &quot;cough&quot; &quot;aches&quot; ## [22] &quot;vomit&quot; &quot;time_admission&quot; &quot;merged_header&quot; ## [25] &quot;x25&quot; As well as everything() there are several special functions that work within select(), namely: everything() - all other columns not mentioned last_col() - the last column where() - applies a function to all columns and selects those which are TRUE starts_with() - matches to a specified prefix. Example: select(starts_with(\"date\")) ends_with() - matches to a specified suffix. Example: select(ends_with(\"_end\")) contains() - columns containing a character string. Example: select(contains(\"time\")) matches() - to apply a regular expression (regex). Example: select(contains(\"[pt]al\")) num_range() - any_of() - matches if column is named. Useful if the name might not exist. Example: select(any_of(date_onset, date_death, cardiac_arrest)) Here is an example using where(): # select columns containing certain characters linelist %&gt;% select(contains(&quot;date&quot;)) %&gt;% names() ## [1] &quot;date_infection&quot; &quot;date_onset&quot; &quot;date_hospitalisation&quot; ## [4] &quot;date_outcome&quot; # searched for multiple character matches linelist %&gt;% select(matches(&quot;onset|hosp|fev&quot;)) %&gt;% # note the OR symbol &quot;|&quot; names() ## [1] &quot;date_onset&quot; &quot;date_hospitalisation&quot; &quot;hospital&quot; ## [4] &quot;fever&quot; 4.5.2 select() as a stand-alone command Select can also be used as an independent command (not in a pipe chain). In this case, the first argument is the original dataframe to be operated upon. # Create a new linelist with id and age-related columns linelist_age &lt;- select(linelist, case_id, contains(&quot;age&quot;)) # display the column names names(linelist_age) ## [1] &quot;case_id&quot; &quot;age&quot; &quot;age_unit&quot; 4.5.3 Add to the pipe chain In the linelist, there are a few columns we do not need: row_num, merged_header, and x25. Remove them by adding a select() command to the cleaning pipe chain: # CLEANING &#39;PIPE&#39; CHAIN (starts with raw data and pipes it through cleaning steps) ################################################################################## # begin cleaning pipe chain ########################### linelist &lt;- linelist_raw %&gt;% # standardize column name syntax janitor::clean_names() %&gt;% # manually re-name columns # NEW name # OLD name rename(date_infection = infection_date, date_hospitalisation = hosp_date, date_outcome = date_of_outcome) %&gt;% # remove column select(-c(row_num, merged_header, x25)) 4.6 Modify class CAUTION: This tab may follow from previous tabs. See section on object classes Often you will need to set the correct class for a column. The most common approach is to use mutate() to define the column as itself, but with a different class. Generally, this looks like this: # Examples of modifying class linelist &lt;- linelist %&gt;% mutate(date_var = as.Date(date_var, format = &quot;MM/DD/YYYY&quot;), # format should be the format of the raw data numeric_var = as.numeric(numeric_var), character_var = as.character(character_var), factor_var = factor(factor_var, levels = c(), labels = c()) ) 4.6.1 Pre-checks and errors First we run some checks on the classes of important columns. The class of the age column is character. To perform analysis, we need those numbers to be recognized as numeric! class(linelist$age) ## [1] &quot;character&quot; The class of the date_onset column is also character! To perform analysis, these dates must be recognized as dates! class(linelist$date_onset) ## [1] &quot;character&quot; However, if we try to classify the date_onset column as date, we would get an error. Use table() or sort or another method to examine all the values and identify different one. For example in our dataset we see that we see that one date_onset value was entered in a different format (15th April 2014) than all the other values! ## ## 15th April 2014 2012-05-03 2012-05-06 2012-05-08 2012-05-16 ## 1 1 1 1 1 ## 2012-05-21 ## 1 Before we can classify date_onset as a date, this value must be fixed to be the same format as the others. You can fix the date in the source data, or, we can do in the cleaning pipeline via mutate() and recode(). This must be done before the commands to convert to class Date. (LINK TO DATE SECTION). # fix incorrect values # old value # new value mutate(date_onset = recode(date_onset, &quot;15th April 2014&quot; = &quot;2014-04-15&quot;)) The mutate() line can be read as: mutate date_onset to equal date_onset recoded so that OLD VALUE is changed to NEW VALUE. Note that this pattern (OLD = NEW) for recode() is the opposite of most R patterns (new = old). The R development community is working on revising this for recoding. Especially after converting to class date, check your data visually or with table() to confirm that they were converted correctly! For as.Date(), the format = argument is often a source of errors. 4.6.2 Modify multiple columns You can use The dplyr function across() with mutate() to convert several columns at once to a new class. across() allows you to specify which columns you want a function to apply to. Below, we want to mutate the columns where is.POSIXct() (a type of date/time class that shows unnecessary timestamps) is TRUE, and apply the function is.Date() to them, in order to convert them to class date. Note that within across() we also use the function where(). Note that is.POSIXct is from the package lubridate. Other similar functions (is.character(), is.numeric(), and is.logical()) are from base R Note that the functions in across() are written without the empty parentheses () linelist &lt;- linelist %&gt;% mutate(across(where(lubridate::is.POSIXct), as.Date)) Below, the described cleaning steps are added to the pipe chain. # CLEANING &#39;PIPE&#39; CHAIN (starts with raw data and pipes it through cleaning steps) ################################################################################## # begin cleaning pipe chain ########################### linelist &lt;- linelist_raw %&gt;% # standardize column name syntax janitor::clean_names() %&gt;% # manually re-name columns # NEW name # OLD name rename(date_infection = infection_date, date_hospitalisation = hosp_date, date_outcome = date_of_outcome) %&gt;% # remove column select(-c(row_num, merged_header, x25)) %&gt;% # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED ################################################### # fix incorrect values # old value # new value mutate(date_onset = recode(date_onset, &quot;15th April 2014&quot; = &quot;2014-04-15&quot;)) %&gt;% # correct the class of the columns mutate(across(contains(&quot;date&quot;), as.Date), generation = as.numeric(generation), age = as.numeric(age)) 4.7 Add columns and rows See the tabs below to add columns and rows 4.7.1 Add columns 4.7.1.1 mutate() We advise creating new columns with dplyr functions as part of a chain of such verb functions (e.g. filter, mutate, etc.) If in need of a stand-alone command, you can use mutate() or the base R style to create a new column (see below). The verb mutate() is used to add a new column, or to modify an existing one. Below is an example of creating a new columns with mutate(). The syntax is: new_column_name = value or function. linelist &lt;- linelist %&gt;% mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) It is best practice to separate each new column with a comma and new line. Below, some practice columns are created: linelist &lt;- linelist %&gt;% # creating new, or modifying old dataset mutate(new_var_dup = case_id, # new column = duplicate/copy another column new_var_static = 7, # new column = all values the same new_var_static = new_var_static + 5, # you can overwrite a column, and it can be a calculation using other variables new_var_paste = stringr::str_glue(&quot;{hospital} on ({date_hospitalisation})&quot;) # new column = pasting together values from other columns ) Scroll to the right to see the new columns (first 50 rows): TIP: The verb transmute() adds new columns just like mutate() but also drops/removes all other columns that you do not mention. 4.7.1.2 New columns using base R To define a new column (or re-define a column) using base R, just use the assignment operator as below. Remember that when using base R you must specify the dataframe before writing the column name (e.g. dataframe$column). Here are two dummy examples: linelist$old_var &lt;- linelist$old_var + 7 linelist$new_var &lt;- linelist$old_var + linelist$age 4.7.2 Add rows TO DO Remember that each column must contain values of only one class (either character, numeric, logical, etc.). So adding a row requires nuance to maintain this. linelist &lt;- linelist %&gt;% add_row(row_num = 666, case_id = &quot;abc&quot;, generation = 4, `infection date` = as.Date(&quot;2020-10-10&quot;), .before = 2) use .before and .after. .before = 3 will put it before the 3rd row. Default is to add it to the end. columns not specified will be let empty. The new row number may look strange (23) but the row numbers have changed. So if using the command twice examine/test carefully. If your class is off you will see an error like this: Error: Cant combine ..1$infection date and ..2$infection date . (for a date value remember to wrap the date in the functionas.Date() like as.Date(\"2020-10-10\")) 4.7.3 New columns using grouped values CAUTION: This tab may follow from previous tabs. Using mutate on GROUPED dataframes https://dplyr.tidyverse.org/reference/mutate.html Taken from website above: #Because mutating expressions are computed within groups, they may yield different results on grouped tibbles. This will be the case as #soon as an aggregating, lagging, or ranking function is involved. Compare this ungrouped mutate: starwars %&gt;% select(name, mass, species) %&gt;% mutate(mass_norm = mass / mean(mass, na.rm = TRUE)) With the grouped equivalent: starwars %&gt;% select(name, mass, species) %&gt;% group_by(species) %&gt;% mutate(mass_norm = mass / mean(mass, na.rm = TRUE)) The former normalises mass by the global average whereas the latter normalises by the averages within species levels. 4.7.4 Add to pipe chain # CLEANING &#39;PIPE&#39; CHAIN (starts with raw data and pipes it through cleaning steps) ################################################################################## # begin cleaning pipe chain ########################### linelist &lt;- linelist_raw %&gt;% # standardize column name syntax janitor::clean_names() %&gt;% # manually re-name columns # NEW name # OLD name rename(date_infection = infection_date, date_hospitalisation = hosp_date, date_outcome = date_of_outcome) %&gt;% # remove column select(-c(row_num, merged_header, x25)) %&gt;% # fix incorrect values # old value # new value mutate(date_onset = recode(date_onset, &quot;15th April 2014&quot; = &quot;2014-04-15&quot;)) %&gt;% # correct the class of the columns mutate(across(contains(&quot;date&quot;), as.Date), generation = as.numeric(generation), age = as.numeric(age)) %&gt;% # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED ################################################### # create column: delay to hospitalisation mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) 4.8 Recoding values For example, in linelist the values in the column hospital must be cleaned. There are several different spellings (often the word Hospital is missing an s and is written Hopital), and many missing values. table(linelist$hospital, useNA = &quot;always&quot;) ## ## Central Hopital Central Hospital ## 11 451 ## Hospital A Hospital B ## 290 289 ## Military Hopital Military Hospital ## 30 805 ## Mitylira Hopital Mitylira Hospital ## 1 81 ## Other Port Hopital ## 904 47 ## Port Hospital St. Mark&#39;s Maternity Hospital (SMMH) ## 1770 418 ## St. Marks Maternity Hopital (SMMH) &lt;NA&gt; ## 11 1501 4.8.1 Manual recoding These tabs demonstrate re-coding values manually b providing specific spellings to be corrected: Using replace() for specific rows Using recode() for entire columns Using base R 4.8.1.1 replace() To manually change values for specific rows within a dataframe (from within a pipe chain), use replace() within mutate(). Use a logic condition to specify rows, for example an ID value of one row. The general syntax is: mutate(col_to_change = replace(col_to_change, criteria for rows, new value)). In the first example below, the gender value, in the row where id is 2195, is changed to Female. # Example: change gender of one specific observation to &quot;Female&quot; mutate(gender = replace(gender, id == &quot;2195&quot;, &quot;Female&quot;) # Example: chance gender of one specific observation to NA mutate(gender = replace(gender, id == &quot;2195&quot;, NA) 4.8.1.2 recode() To change spellings manually, one-by-one, you can use the recode() function *within the mutate() function. The code is saying that the column hospital should be defined as the current column hospital, but with certain changes (the syntax is OLD = NEW). Dont forget commas! linelist &lt;- linelist %&gt;% mutate(hospital = recode(hospital, # OLD = NEW &quot;Mitylira Hopital&quot; = &quot;Military Hospital&quot;, &quot;Mitylira Hospital&quot; = &quot;Military Hospital&quot;, &quot;Military Hopital&quot; = &quot;Military Hospital&quot;, &quot;Port Hopital&quot; = &quot;Port Hospital&quot;, &quot;Central Hopital&quot; = &quot;Central Hospital&quot;, &quot;other&quot; = &quot;Other&quot;, &quot;St. Marks Maternity Hopital (SMMH)&quot; = &quot;St. Mark&#39;s Maternity Hospital (SMMH)&quot; )) Now we see the values in the hospital column have been corrected: table(linelist$hospital, useNA = &quot;always&quot;) ## ## Central Hospital Hospital A ## 462 290 ## Hospital B Military Hospital ## 289 917 ## Other Port Hospital ## 904 1817 ## St. Mark&#39;s Maternity Hospital (SMMH) &lt;NA&gt; ## 429 1501 TIP: The number of spaces before and after an equals sign does not matter. Make your code easier to read by aligning the = for all or most rows. Also, consider adding a hashed comment row to clarify for future readers which side is OLD and which side is NEW. TIP: Sometimes a blank character value exists in a dataset (not recognized as Rs value for missing - NA). You can reference this value with two quotation marks with no space inbetween (\"\"). 4.8.1.3 base R If necessary, you make manual changes to a specific value in a dataframe by referencing the row number of case ID. But remember it is better if you can make these changes permanently in the underlying data! Here is a fake example. It reads as Change the value of the dataframe linelists column onset_date (for the row where linelists column case_id has the value 9d4019) to as.Date(\"2020-10-24\"). linelist$date_onset[linelist$case_id == &quot;9d4019&quot;] &lt;- as.Date(&quot;2020-10-24&quot;) 4.8.2 Recoding by logic These tabs demonstrate re-coding values in a column using logic and conditions: Using case_when() Using ifelse() and if_else() Using special dplyr recoding functions like: replace_na() na_if() coalesnce() 4.8.2.1 case_when() If you need to use logic statements to recode values, or want to use operators like %in%, use dplyrs case_when() instead. If you use case_when() please read the thorough explanation HERE LINK, as there are important differences from recode() in syntax and logic order! Note that all Right-hand side (RHS) inputs must be of the same class (e.g. character, numeric, logical). Notice the use of the special value NA_real_ instead of just NA. linelist &lt;- linelist %&gt;% dplyr::mutate(age_years = case_when( age_unit == &quot;years&quot; ~ age, # if age is given in years age_unit == &quot;months&quot; ~ age/12, # if age is given in months is.na(age_unit) ~ age, # if age unit is missing, assume years TRUE ~ NA_real_)) # Any other circumstance 4.8.2.2 ifelse() and if_else() For simple uses of logical re-coding or new variable creationgyou can use ifelse() or if_else(). Though in most cases it is better to use case_when(). These commands are simplified versions of an if and else statement. The general syntax is ifelse(condition, value if condition evaluates to TRUE, value if condition evaluates to FALSE). If used in a mutate(), each row is evaluated. if_else() is a special version from dplyr that handles dates in the condition. It can be tempting to string together many ifelse commands resist this and use case_when() instead! It is much more simple, easier to read, and easier to identify errors. IMAGE of ifelse string with X across is. You can reference other columns with the ifelse() function within mutate(): Example of ifelse(): linelist &lt;- linelist %&gt;% mutate(source_known = ifelse(!is.na(source), &quot;known&quot;, &quot;unknown&quot;)) Example of if_else() (using dates): Note that if the true value is a date, the false value must also qualify a date, hence using the special character NA_real_ instead of just NA. linelist &lt;- linelist %&gt;% mutate(date_death = if_else(outcome == &quot;Death&quot;, date_outcome, NA_real_)) Note: If you want to alternate a value used in your code based on other circumstances, consider using switch() from base R. For example if TO DO. See the section on using switch() in the page on R interactive console. 4.8.3 Recoding using special dplyr functions 4.8.3.1 Using replace_na() To change missing values (NA) to a specific character value, such as Missing, use the function replace_na() within mutate(). Note that this is used in the same manner as recode above - the name of the variable must be repeated within replace_na(). linelist &lt;- linelist %&gt;% mutate(hospital = replace_na(hospital, &quot;Missing&quot;)) 4.8.3.2 Using na_if() Likewise you can quickly convert a specific character value to NA using na_if(). The command below is the opposite of the one above. It converts any values of Missing to NA. linelist &lt;- linelist %&gt;% mutate(hospital = na_if(hospital, &quot;Missing&quot;)) 4.8.3.3 Using coalesce() This dplyr function finds the first non-missing value at each position. So, you provide it with columns and for each row it will fill the value with the first non-missing value in the columns you provided. For example, you might use thiscoalesce()` create a location variable from hypothetical variables patient_residence and reporting_jurisdiction, where you prioritize patient residence information, if it exists. linelist &lt;- linelist %&gt;% mutate(location = coalesce(patient_residence, reporting_jurisdiction)) TO DO lead(), lag() cumsum(), cummean(), cummin(), cummax(), cumany(), cumall(), 4.8.4 Recoding using cleaning dictionaries CAUTION: This tab may follow from previous tabs. ## load cleaning rules and only keep columns in mll mll_cleaning_rules &lt;- import(here(&quot;dictionaries/mll_cleaning_rules.xlsx&quot;)) %&gt;% filter(column %in% c(names(mll_raw), &quot;.global&quot;)) ## define columns that are not cleand unchanged &lt;- c( &quot;epilink_relationship&quot;, &quot;narratives&quot;, &quot;epilink_relationship_detail&quot; ) mll_clean &lt;- mll_raw %&gt;% ## convert to tibble as_tibble() %&gt;% ## clean columns using cleaning rules clean_data( wordlists = mll_cleaning_rules, protect = names(.) %in% unchanged ) 4.8.5 Add to pipe chain Here we add the described cleaning steps to the pipe chain. # CLEANING &#39;PIPE&#39; CHAIN (starts with raw data and pipes it through cleaning steps) ################################################################################## # begin cleaning pipe chain ########################### linelist &lt;- linelist_raw %&gt;% # standardize column name syntax janitor::clean_names() %&gt;% # manually re-name columns # NEW name # OLD name rename(date_infection = infection_date, date_hospitalisation = hosp_date, date_outcome = date_of_outcome) %&gt;% # remove column select(-c(row_num, merged_header, x25)) %&gt;% # fix incorrect values # old value # new value mutate(date_onset = recode(date_onset, &quot;15th April 2014&quot; = &quot;2014-04-15&quot;)) %&gt;% # correct the class of the columns mutate(across(contains(&quot;date&quot;), as.Date), generation = as.numeric(generation), age = as.numeric(age)) %&gt;% # create column: delay to hospitalisation mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED ################################################### # clean values of hospital column mutate(hospital = recode(hospital, # OLD = NEW &quot;Mitylira Hopital&quot; = &quot;Military Hospital&quot;, &quot;Mitylira Hospital&quot; = &quot;Military Hospital&quot;, &quot;Military Hopital&quot; = &quot;Military Hospital&quot;, &quot;Port Hopital&quot; = &quot;Port Hospital&quot;, &quot;Central Hopital&quot; = &quot;Central Hospital&quot;, &quot;other&quot; = &quot;Other&quot;, &quot;St. Marks Maternity Hopital (SMMH)&quot; = &quot;St. Mark&#39;s Maternity Hospital (SMMH)&quot; )) %&gt;% mutate(hospital = replace_na(hospital, &quot;Missing&quot;)) %&gt;% # create age_years column (from age and age_unit) mutate(age_years = case_when( age_unit == &quot;years&quot; ~ age, age_unit == &quot;months&quot; ~ age/12, is.na(age_unit) ~ age, TRUE ~ NA_real_)) 4.9 Filter rows CAUTION: This tab may follow from previous tabs. A typical early cleaning step is to filter the dataframe for specific rows using the dplyr verb filter(). Within filter(), give the logic that must be TRUE for a row in the dataset to be kept. The tabs below show how to filter rows based on simple and complex logical conditions, and how to filter/subset rows as a stand-alone command and with base R 4.9.1 A simple filter() This simple example re-defines the dataframe linelist as itself, having filtered the rows to meet a logical condition. Only the rows where the logical statement within the parentheses is TRUE are kept. In this case, the logical statement is !is.na(case_id), which is asking whether the value in the column case_id is not missing (NA). Thus, rows where case_id is not missing are kept. Before the filter is applied, the number of rows in linelist is 6609. linelist &lt;- linelist %&gt;% filter(!is.na(case_id)) # keep only rows where case_id is not missing After the filter is applied, the number of rows in linelist is 6603. 4.9.2 A complex filter() A more complex example using filter(): 4.9.2.1 Examine the data Below is a simple one-line command to create a histogram of onset dates. See that a second smaller outbreak from 2012-2013 is also included in this dataset. For our analyses, we want to remove entries from this earlier outbreak. hist(linelist$date_onset, breaks = 50) 4.9.2.2 How filters handle missing numeric and date values Can we just filter by date_onset to rows after June 2013? Caution! Applying the code filter(date_onset &gt; as.Date(\"2013-06-01\"))) would accidentally remove any rows in the later epidemic with a missing date of onset! DANGER: Filtering to greater than (&gt;) or less than (&lt;) a date or number can remove any rows with missing values (NA)! This is because NA is treated as infinitely large and small. 4.9.2.3 Design the filter Examine a cross-tabulation to make sure we exclude only the correct rows: table(Hospital = linelist$hospital, # hospital name YearOnset = lubridate::year(linelist$date_onset), # year of date_onset useNA = &quot;always&quot;) # show missing values ## YearOnset ## Hospital 2012 2013 2014 2015 &lt;NA&gt; ## Central Hospital 0 0 366 96 0 ## Hospital A 225 65 0 0 0 ## Hospital B 220 66 0 0 0 ## Military Hospital 0 0 717 200 0 ## Missing 0 0 1180 318 0 ## Other 0 0 724 180 0 ## Port Hospital 10 0 1462 345 0 ## St. Mark&#39;s Maternity Hospital (SMMH) 0 0 336 93 0 ## &lt;NA&gt; 0 0 0 0 0 What other criteria can we filter on to remove the first outbreak from the dataset? We see that: The first epidemic occurred at Hospital A, Hospital B, and that there were also 10 cases at Port Hospital. Hospitals A &amp; B did not have cases in the second epidemic, but Port Hospital did. We want to exclude: The 586 rows with onset in 2012 and 2013 at either hospital A, B, or Port: Exclude the 586 rows with onset in 2012 and 2013 Exclude the 0 rows from Hospitals A &amp; B with missing onset dates Do not exclude the 0 other rows with missing onset dates. We start with a linelist of nrow(linelist). Here is our filter statement: linelist &lt;- linelist %&gt;% # keep rows where onset is after 1 June 2013 OR where onset is missing and it was a hospital OTHER than Hospital A or B filter(date_onset &gt; as.Date(&quot;2013-06-01&quot;) | (is.na(date_onset) &amp; !hospital %in% c(&quot;Hospital A&quot;, &quot;Hospital B&quot;))) nrow(linelist) ## [1] 6017 When we re-make the cross-tabulation, we see that Hospitals A &amp; B are removed completely, and the 10 Port Hospital cases from 2012 &amp; 2013 are removed, and all other values are the same - just as we wanted. table(Hospital = linelist$hospital, # hospital name YearOnset = lubridate::year(linelist$date_onset), # year of date_onset useNA = &quot;always&quot;) # show missing values ## YearOnset ## Hospital 2014 2015 &lt;NA&gt; ## Central Hospital 366 96 0 ## Military Hospital 717 200 0 ## Missing 1180 318 0 ## Other 724 180 0 ## Port Hospital 1462 345 0 ## St. Mark&#39;s Maternity Hospital (SMMH) 336 93 0 ## &lt;NA&gt; 0 0 0 Multiple statements can be included within one filter command (separated by commas), or you can always pipe to a separate filter() command for clarity. Note: some readers may notice that it would be easier to just filter by date_hospitalisation because it is 100% complete. This is true. But for pdate_onset is used for purposes of a complex filter example. 4.9.3 Filter as a stand-alone command Filtering can also be done as a stand-alone command (not part of a pipe chain). Like other dplyr verbs, in this case the first argument must be the dataset itself. # dataframe &lt;- filter(dataframe, condition(s) for rows to keep) linelist &lt;- filter(linelist, !is.na(case_id)) You can also use base R to subset using square brackets which reflect the [rows, columns] that you want to retain. # dataframe &lt;- dataframe[row conditions, column conditions] (blank means keep all) linelist &lt;- linelist[!is.na(case_id), ] TIP: Use bracket-subset syntax with View() to quickly review a few records. 4.9.4 Filtering to quickly review data This base R syntax can be handy when you want to quickly view a subset of rows and columns. Use the base R View() command (note the capital V) around the [] subset you want to see. The result will appear as a dataframe in your RStudio viewer panel. For example, if I want to review onset and hospitalization dates of 3 specific cases: View the linelist in the viewer panel: View(linelist) View specific data for three cases: View(linelist[linelist$case_id %in% c(&quot;11f8ea&quot;, &quot;76b97a&quot;, &quot;47a5f5&quot;), c(&quot;date_onset&quot;, &quot;date_hospitalisation&quot;)]) Note: the above command can also be written with dplyr verbs filter() and select() as below: View(linelist %&gt;% filter(case_id %in% c(&quot;11f8ea&quot;, &quot;76b97a&quot;, &quot;47a5f5&quot;)) %&gt;% select(date_onset, date_hospitalisation)) 4.9.5 Add to pipe chain # CLEANING &#39;PIPE&#39; CHAIN (starts with raw data and pipes it through cleaning steps) ################################################################################## # begin cleaning pipe chain ########################### linelist &lt;- linelist_raw %&gt;% # standardize column name syntax janitor::clean_names() %&gt;% # manually re-name columns # NEW name # OLD name rename(date_infection = infection_date, date_hospitalisation = hosp_date, date_outcome = date_of_outcome) %&gt;% # remove column select(-c(row_num, merged_header, x25)) %&gt;% # fix incorrect values # old value # new value mutate(date_onset = recode(date_onset, &quot;15th April 2014&quot; = &quot;2014-04-15&quot;)) %&gt;% # correct the class of the columns mutate(across(contains(&quot;date&quot;), as.Date), generation = as.numeric(generation), age = as.numeric(age)) %&gt;% # create column: delay to hospitalisation mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% # clean values of hospital column mutate(hospital = recode(hospital, # OLD = NEW &quot;Mitylira Hopital&quot; = &quot;Military Hospital&quot;, &quot;Mitylira Hospital&quot; = &quot;Military Hospital&quot;, &quot;Military Hopital&quot; = &quot;Military Hospital&quot;, &quot;Port Hopital&quot; = &quot;Port Hospital&quot;, &quot;Central Hopital&quot; = &quot;Central Hospital&quot;, &quot;other&quot; = &quot;Other&quot;, &quot;St. Marks Maternity Hopital (SMMH)&quot; = &quot;St. Mark&#39;s Maternity Hospital (SMMH)&quot; )) %&gt;% mutate(hospital = replace_na(hospital, &quot;Missing&quot;)) %&gt;% # create age_years column (from age and age_unit) mutate(age_years = case_when( age_unit == &quot;years&quot; ~ age, age_unit == &quot;months&quot; ~ age/12, is.na(age_unit) ~ age, TRUE ~ NA_real_)) %&gt;% # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED ################################################### filter( # keep only rows where case_id is not missing !is.na(case_id), # also filter to keep only the second outbreak date_onset &gt; as.Date(&quot;2013-06-01&quot;) | (is.na(date_onset) &amp; !hospital %in% c(&quot;Hospital A&quot;, &quot;Hospital B&quot;))) 4.10 Numeric categories CAUTION: This tab may follow from previous tabs. Special approaches for creating numeric categories Common examples include age categories, groups of lab values, etc. There are several ways to create categories of a numeric column such as age. Here we will discuss: age_categories(), from the epikit package cut(), from base R using percentiles to break your numbers natural break points ? TO DO case_when() Sometimes, numeric variables will import as class character. This occurs if there are non-numeric characters in some of the values, for example an entry of 2 months for age, or (depending on your R locale settings) if a comma is used in the decimals place (e.g. 4,5 to mean four and one half years). For this example we will create an age_cat column using the age_years column. #check the class of the linelist variable age class(linelist$age_years) ## [1] &quot;numeric&quot; 4.10.1 age_categories()** With the epikit package, you can use the age_categories() function to easily categorize and label numeric columns (note: this can be applied to non-age numeric variables too). The output is an ordered factor. The break values specified are included in the higher group, that is groups are open on the lower/left side. As shown below, you can add 1 to each break value to achieve groups that are open at the top/right. Other optional arguments: lower = Default is 0). The lowest number you want considered. upper = The highest number you want considered. by = The number of years between groups. separator = Default is -. Character between ages in labels. ceiling = Default FALSE. If TRUE, the highest break value is a ceiling and a category XX+ is not included. Any values above highest break or upper (if defined) are categorized as NA. See the functions Help page for more details (enter ?age_categories in the R console). library(epikit) # Simple example ################ linelist &lt;- linelist %&gt;% mutate(age_cat = age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70))) # show table table(linelist$age_cat, useNA = &quot;always&quot;) ## ## 0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+ &lt;NA&gt; ## 1078 1181 981 908 1089 665 24 0 91 # With ceiling set to TRUE ########################## linelist &lt;- linelist %&gt;% mutate(age_cat = age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70), upper = max(linelist$age_years, na.rm=T), ceiling = TRUE)) # 70 is the ceiling # show table table(linelist$age_cat, useNA = &quot;always&quot;) ## ## 0-4 5-9 10-14 15-19 20-29 30-49 50-70 &lt;NA&gt; ## 1078 1181 981 908 1089 665 24 91 # Include upper ends for the same categories ############################################ linelist &lt;- linelist %&gt;% mutate(age_cat = age_categories(age_years, upper = max(linelist$age_years, na.rm=T), breakers = c(0, 6, 11, 16, 21, 31, 51, 71, 76))) # show table table(linelist$age_cat, useNA = &quot;always&quot;) ## ## 0-5 6-10 11-15 16-20 21-30 31-50 51-70 71-75 76+ &lt;NA&gt; ## 1328 1149 977 818 1035 599 20 0 0 91 4.10.2 cut() You can use the base R function cut(), which creates categories from a numeric variable. The differences from age_categories() are: You do not need to install/load another package You can specify whether groups are open/closed on the right/left You must provide labels yourself (and ensure they are accurate to the groups) If you want 0 included in the lowest group you must specify this The basic syntax within cut() is to first provide the numeric variable to be cut (age_years), and then the breaks argument, which is a numeric vector (c()) of break points. Using cut(), the resulting column is an ordered factor. If used within mutate() (a dplyr verb) it is not necessary to specify the dataframe before the column name (e.g. linelist$age_years). 4.10.2.1 Simple cut() example Create new column of age categories (age_cat) by cutting the numeric age_year column at specified break points. The example below replicates the first age_categories() example. Specify numeric vector of break points c(0, 5, 10, 15, ...) Default behavior for cut() is that lower break values are excluded from each category, and upper break values are included. This is the opposite behavior from the age_categories() function. Include 0 in the lowest category by adding include.lowest = TRUE Add a vector of customized labels using the labels = argument Check your work with cross-tabulation of the numeric and category columns - be aware of missing values linelist &lt;- linelist %&gt;% mutate(age_cat = cut(age_years, # numeric column breaks = c(0, 5, 10, 15, 20, 30, 50, 70, # break points... max(linelist$age_years, na.rm=T)), # ... with dynamic last break as column max value right = TRUE, # lower breaks included and upper excluded [a,b) include.lowest = TRUE, # 0 included in lowest category labels = c(&quot;0-4&quot;, &quot;5-9&quot;, &quot;10-14&quot;, &quot;15-19&quot;, # manual labels - be careful! &quot;20-29&quot;, &quot;30-49&quot;, &quot;50-69&quot;, &quot;70+&quot;))) table(linelist$age_cat, useNA = &quot;always&quot;) ## ## 0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+ &lt;NA&gt; ## 1328 1149 977 818 1035 599 20 0 91 4.10.2.2 cut() details Below is a detailed description of the behavior of using cut() to make the age_cat column. Key points: Inclusion/exclusion behavior of break points Custom category labels Handling missing values Check your work! The most simple command of cut() applied to age_years to make the new variable age_cat is below: # Create new variable, by cutting the numeric age variable # by default, upper break is excluded and lower break excluded from each category linelist &lt;- linelist %&gt;% mutate(age_cat = cut(age_years, breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100))) # tabulate the number of observations per group table(linelist$age_cat, useNA = &quot;always&quot;) ## ## (0,5] (5,10] (10,15] (15,20] (20,30] (30,50] (50,70] (70,100] ## 1215 1149 977 818 1035 599 20 0 ## &lt;NA&gt; ## 204 By default, the categorization occurs so that the right/upper side is open and inclusive (and the left/lower side is closed or exclusive). The default labels use the notation (A, B], which means the group does not include A (the lower break value), but includes B (the upper break value). Reverse this behavior by providing the right = TRUE argument. Thus, by default 0 values are excluded from the lowest group, and categorized as NA. 0 values could be infants coded as age 0. To change this add the argument include.lowest = TRUE. Then, any 0 values are included in the lowest group. The automatically-generated label for the lowest category will change from (0,B] to [0,B], which signifies that 0 values are included. Check your work!!! Verify that each age value was assigned to the correct category by cross-tabulating the numeric and category columns. Examine assignment of boundary values (e.g. 15, if neighboring categories are 10-15 and 15-20). # Cross tabulation of the numeric and category columns. table(&quot;Numeric Values&quot; = linelist$age_years, # names specified in table for clarity. &quot;Categories&quot; = linelist$age_cat, useNA = &quot;always&quot;) # don&#39;t forget to examine NA values ## Categories ## Numeric Values (0,5] (5,10] (10,15] (15,20] (20,30] (30,50] (50,70] ## 0 0 0 0 0 0 0 0 ## 0.0833333333333333 2 0 0 0 0 0 0 ## 0.166666666666667 3 0 0 0 0 0 0 ## 0.25 2 0 0 0 0 0 0 ## 0.333333333333333 2 0 0 0 0 0 0 ## 0.416666666666667 3 0 0 0 0 0 0 ## 0.5 2 0 0 0 0 0 0 ## 0.583333333333333 1 0 0 0 0 0 0 ## 0.666666666666667 3 0 0 0 0 0 0 ## 0.75 1 0 0 0 0 0 0 ## 0.833333333333333 1 0 0 0 0 0 0 ## 0.916666666666667 3 0 0 0 0 0 0 ## 1 263 0 0 0 0 0 0 ## 1.5 1 0 0 0 0 0 0 ## 2 249 0 0 0 0 0 0 ## 3 226 0 0 0 0 0 0 ## 4 203 0 0 0 0 0 0 ## 5 250 0 0 0 0 0 0 ## 6 0 234 0 0 0 0 0 ## 7 0 240 0 0 0 0 0 ## 8 0 220 0 0 0 0 0 ## 9 0 237 0 0 0 0 0 ## 10 0 218 0 0 0 0 0 ## 11 0 0 195 0 0 0 0 ## 12 0 0 190 0 0 0 0 ## 13 0 0 179 0 0 0 0 ## 14 0 0 199 0 0 0 0 ## 15 0 0 214 0 0 0 0 ## 16 0 0 0 194 0 0 0 ## 17 0 0 0 164 0 0 0 ## 18 0 0 0 177 0 0 0 ## 19 0 0 0 159 0 0 0 ## 20 0 0 0 124 0 0 0 ## 21 0 0 0 0 140 0 0 ## 22 0 0 0 0 121 0 0 ## 23 0 0 0 0 108 0 0 ## 24 0 0 0 0 95 0 0 ## 25 0 0 0 0 109 0 0 ## 26 0 0 0 0 108 0 0 ## 27 0 0 0 0 98 0 0 ## 28 0 0 0 0 100 0 0 ## 29 0 0 0 0 86 0 0 ## 30 0 0 0 0 70 0 0 ## 31 0 0 0 0 0 70 0 ## 32 0 0 0 0 0 71 0 ## 33 0 0 0 0 0 55 0 ## 34 0 0 0 0 0 52 0 ## 35 0 0 0 0 0 43 0 ## 36 0 0 0 0 0 35 0 ## 37 0 0 0 0 0 29 0 ## 38 0 0 0 0 0 37 0 ## 39 0 0 0 0 0 27 0 ## 40 0 0 0 0 0 36 0 ## 41 0 0 0 0 0 20 0 ## 42 0 0 0 0 0 17 0 ## 43 0 0 0 0 0 21 0 ## 44 0 0 0 0 0 21 0 ## 45 0 0 0 0 0 20 0 ## 46 0 0 0 0 0 14 0 ## 47 0 0 0 0 0 9 0 ## 48 0 0 0 0 0 7 0 ## 49 0 0 0 0 0 11 0 ## 50 0 0 0 0 0 4 0 ## 51 0 0 0 0 0 0 3 ## 52 0 0 0 0 0 0 4 ## 53 0 0 0 0 0 0 3 ## 55 0 0 0 0 0 0 2 ## 56 0 0 0 0 0 0 1 ## 58 0 0 0 0 0 0 1 ## 59 0 0 0 0 0 0 2 ## 62 0 0 0 0 0 0 1 ## 63 0 0 0 0 0 0 1 ## 65 0 0 0 0 0 0 1 ## 66 0 0 0 0 0 0 1 ## &lt;NA&gt; 0 0 0 0 0 0 0 ## Categories ## Numeric Values (70,100] &lt;NA&gt; ## 0 0 113 ## 0.0833333333333333 0 0 ## 0.166666666666667 0 0 ## 0.25 0 0 ## 0.333333333333333 0 0 ## 0.416666666666667 0 0 ## 0.5 0 0 ## 0.583333333333333 0 0 ## 0.666666666666667 0 0 ## 0.75 0 0 ## 0.833333333333333 0 0 ## 0.916666666666667 0 0 ## 1 0 0 ## 1.5 0 0 ## 2 0 0 ## 3 0 0 ## 4 0 0 ## 5 0 0 ## 6 0 0 ## 7 0 0 ## 8 0 0 ## 9 0 0 ## 10 0 0 ## 11 0 0 ## 12 0 0 ## 13 0 0 ## 14 0 0 ## 15 0 0 ## 16 0 0 ## 17 0 0 ## 18 0 0 ## 19 0 0 ## 20 0 0 ## 21 0 0 ## 22 0 0 ## 23 0 0 ## 24 0 0 ## 25 0 0 ## 26 0 0 ## 27 0 0 ## 28 0 0 ## 29 0 0 ## 30 0 0 ## 31 0 0 ## 32 0 0 ## 33 0 0 ## 34 0 0 ## 35 0 0 ## 36 0 0 ## 37 0 0 ## 38 0 0 ## 39 0 0 ## 40 0 0 ## 41 0 0 ## 42 0 0 ## 43 0 0 ## 44 0 0 ## 45 0 0 ## 46 0 0 ## 47 0 0 ## 48 0 0 ## 49 0 0 ## 50 0 0 ## 51 0 0 ## 52 0 0 ## 53 0 0 ## 55 0 0 ## 56 0 0 ## 58 0 0 ## 59 0 0 ## 62 0 0 ## 63 0 0 ## 65 0 0 ## 66 0 0 ## &lt;NA&gt; 0 91 Read more about cut() in its Help page by entering ?cut in the R console. Reversing break inclusion behavior in cut() Lower break values will be included in each category (and upper break values excluded) if the argument right = is included and and set to TRUE. This is applied below - note how the values have shifted among the categories. NOTE: If you include the include.lowest = TRUE argument and right = TRUE, the include.lowest will now apply to the highest break point value and category, not the lowest. linelist &lt;- linelist %&gt;% mutate(age_cat = cut(age_years, breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100), # same breaks right = FALSE, # include each *lower* break point labels = c(&quot;0-4&quot;, &quot;5-9&quot;, &quot;10-14&quot;, &quot;15-19&quot;, &quot;20-29&quot;, &quot;30-49&quot;, &quot;50-69&quot;, &quot;70-100&quot;))) # now the labels must change table(linelist$age_cat, useNA = &quot;always&quot;) ## ## 0-4 5-9 10-14 15-19 20-29 30-49 50-69 70-100 &lt;NA&gt; ## 1078 1181 981 908 1089 665 24 0 91 Re-labeling NA values with cut() Because cut() does not automatically label NA values, you may want to assign a label such as Missing. This requires a few extra steps because cut() automatically classified the new column age_cat as a Factor (a rigid column class with specific value labels). First, convert age_cut from Factor to Character class, so you have flexibility to add new character values (e.g. Missing). Otherwise you will encounter an error. Then, use the dplyr verb replace_na() to replace NA values with a character value like Missing. These steps can be combined into one step, as shown below. Note that Missing has been added, but the order of the categories is now wrong (alphabetical). linelist &lt;- linelist %&gt;% # cut() creates age_cat, automatically of class Factor mutate(age_cat = cut(age_years, breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100), right = FALSE, labels = c(&quot;0-4&quot;, &quot;5-9&quot;, &quot;10-14&quot;, &quot;15-19&quot;, &quot;20-29&quot;, &quot;30-49&quot;, &quot;50-69&quot;, &quot;70-100&quot;)), # convert to class Character, and replace NA with &quot;Missing&quot; age_cat = replace_na(as.character(age_cat), &quot;Missing&quot;)) table(linelist$age_cat, useNA = &quot;always&quot;) ## ## 0-4 10-14 15-19 20-29 30-49 5-9 50-69 Missing &lt;NA&gt; ## 1078 981 908 1089 665 1181 24 91 0 To fix this, re-convert age_cat to a factor, and define the order of the levels correctly. linelist &lt;- linelist %&gt;% # cut() creates age_cat, automatically of class Factor mutate(age_cat = cut(age_years, breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100), right = FALSE, labels = c(&quot;0-4&quot;, &quot;5-9&quot;, &quot;10-14&quot;, &quot;15-19&quot;, &quot;20-29&quot;, &quot;30-49&quot;, &quot;50-69&quot;, &quot;70-100&quot;)), # convert to class Character, and replace NA with &quot;Missing&quot; age_cat = replace_na(as.character(age_cat), &quot;Missing&quot;), # re-classify age_cat as Factor, with correct level order and new &quot;Missing&quot; level age_cat = factor(age_cat, levels = c(&quot;0-4&quot;, &quot;5-9&quot;, &quot;10-14&quot;, &quot;15-19&quot;, &quot;20-29&quot;, &quot;30-49&quot;, &quot;50-69&quot;, &quot;70-100&quot;, &quot;Missing&quot;))) table(linelist$age_cat, useNA = &quot;always&quot;) ## ## 0-4 5-9 10-14 15-19 20-29 30-49 50-69 70-100 Missing &lt;NA&gt; ## 1078 1181 981 908 1089 665 24 0 91 0 If you want a fast way to make breaks and labels, you can use something like below (adjust to your specific situation). See the page on using seq() and rep() and c() TO DO # Make break points from 0 to 90 by 5 age_seq = seq(from = 0, to = 90, by = 5) age_seq # Make labels for the above categories, assuming default cut() settings age_labels = paste0(age_seq+1, &quot;-&quot;, age_seq + 5) age_labels # check that both vectors are the same length length(age_seq) == length(age_labels) # # Use them in the cut() command # cut(linelist$age, breaks = age_seq, labels = age_labels) 4.10.3 case_when() The dplyr function case_when() can also be used to create numeric categories. Allows explicit setting of break point inclusion/exclusion Allows designation of label for NA values in one step More complicated code, arguably more prone to error Allow more flexibility to include other variables in the logic If using case_when() please review the in-depth page on it, as the logic and order of assignment are important understand to avoid errors. CAUTION: In case_when() all right-hand side values must be of the same class. Thus, if your categories are character values (e.g. 20-30 years) then any designated outcome for NA age values must also be character (Missing, or the special NA_character_ instead of NA). You will need to designate the column as a factor (by wrapping case_when() in the function factor()) and provide the ordering of the factor levels using the levels = argument after the close of the case_when() function. When using cut(), the factor and ordering of levels is done automatically. linelist &lt;- linelist %&gt;% mutate(age_cat = factor(case_when( # provide the case_when logic and outcomes age_years &gt;= 0 &amp; age_years &lt; 5 ~ &quot;0-4&quot;, # logic by age_year value age_years &gt;= 5 &amp; age_years &lt; 10 ~ &quot;5-9&quot;, age_years &gt;= 10 &amp; age_years &lt; 15 ~ &quot;10-14&quot;, age_years &gt;= 15 &amp; age_years &lt; 20 ~ &quot;15-19&quot;, age_years &gt;= 20 &amp; age_years &lt; 30 ~ &quot;20-29&quot;, age_years &gt;= 30 &amp; age_years &lt; 50 ~ &quot;30-49&quot;, age_years &gt;= 50 &amp; age_years &lt; 70 ~ &quot;50-69&quot;, age_years &gt;= 45 &amp; age_years &lt;= 100 ~ &quot;70-100&quot;, is.na(age_years) ~ &quot;Missing&quot;, # if age_years is missing TRUE ~ &quot;Check value&quot; # catch-all alarm to trigger review ), levels = c(&quot;0-4&quot;,&quot;5-9&quot;, &quot;10-14&quot;, &quot;15-19&quot;, &quot;20-29&quot;, &quot;30-49&quot;, &quot;50-69&quot;, &quot;70-100&quot;, &quot;Missing&quot;, &quot;Check value&quot;)) ) table(linelist$age_cat, useNA = &quot;always&quot;) ## ## 0-4 5-9 10-14 15-19 20-29 30-49 ## 1078 1181 981 908 1089 665 ## 50-69 70-100 Missing Check value &lt;NA&gt; ## 24 0 91 0 0 4.10.4 Add to pipe chain Below, code to create two categorical age columns is added to the cleaning pipe chain: # CLEANING &#39;PIPE&#39; CHAIN (starts with raw data and pipes it through cleaning steps) ################################################################################## # begin cleaning pipe chain ########################### linelist &lt;- linelist_raw %&gt;% # standardize column name syntax janitor::clean_names() %&gt;% # manually re-name columns # NEW name # OLD name rename(date_infection = infection_date, date_hospitalisation = hosp_date, date_outcome = date_of_outcome) %&gt;% # remove column select(-c(row_num, merged_header, x25)) %&gt;% # fix incorrect values # old value # new value mutate(date_onset = recode(date_onset, &quot;15th April 2014&quot; = &quot;2014-04-15&quot;)) %&gt;% # correct the class of the columns mutate(across(contains(&quot;date&quot;), as.Date), generation = as.numeric(generation), age = as.numeric(age)) %&gt;% # create column: delay to hospitalisation mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% # clean values of hospital column mutate(hospital = recode(hospital, # OLD = NEW &quot;Mitylira Hopital&quot; = &quot;Military Hospital&quot;, &quot;Mitylira Hospital&quot; = &quot;Military Hospital&quot;, &quot;Military Hopital&quot; = &quot;Military Hospital&quot;, &quot;Port Hopital&quot; = &quot;Port Hospital&quot;, &quot;Central Hopital&quot; = &quot;Central Hospital&quot;, &quot;other&quot; = &quot;Other&quot;, &quot;St. Marks Maternity Hopital (SMMH)&quot; = &quot;St. Mark&#39;s Maternity Hospital (SMMH)&quot; )) %&gt;% mutate(hospital = replace_na(hospital, &quot;Missing&quot;)) %&gt;% # create age_years column (from age and age_unit) mutate(age_years = case_when( age_unit == &quot;years&quot; ~ age, age_unit == &quot;months&quot; ~ age/12, is.na(age_unit) ~ age, TRUE ~ NA_real_)) %&gt;% filter( # keep only rows where case_id is not missing !is.na(case_id), # also filter to keep only the second outbreak date_onset &gt; as.Date(&quot;2013-06-01&quot;) | (is.na(date_onset) &amp; !hospital %in% c(&quot;Hospital A&quot;, &quot;Hospital B&quot;))) %&gt;% # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED ################################################### mutate( # age categories: custom age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)), # age categories: 0 to 85 by 5s age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) 4.11 rowwise() dplyr() https://cran.r-project.org/web/packages/dplyr/vignettes/rowwise.html linelist &lt;- linelist %&gt;% rowwise() %&gt;% mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == &quot;yes&quot;)) 4.12 Transforming multiple variables at once CAUTION: This tab may follow from previous tabs. A transformation can be applied to multiple variables at once using the across() function from the package dplyr (contained within tidyverse package). across() can be used with any dplyr verb, but commonly with as mutate(), filter(), or summarise(). Here are some examples to get started. Example of how one would change all columns to character class #to change all columns to character class linelist &lt;- linelist %&gt;% mutate(across(everything(), as.character)) Change only numeric columns Here are a few online resources on using across(): Hadley Wickhams thoughts/rationale 4.13 Deduplication CAUTION: This tab may follow from previous tabs. The package dplyr offers the distinct() function to reduce the dataframe to only unique rows - removing duplicates. In this case we just want to remove rows that are complete duplicates, so we just add the simple command distinct(). For more complex deduplications see the page on deduplicating. We begin with 6017 rows in linelist. linelist &lt;- linelist %&gt;% distinct() After deduplication there are 5888 rows. Below, the distinct() command is added to the cleaning pipe chain: # CLEANING &#39;PIPE&#39; CHAIN (starts with raw data and pipes it through cleaning steps) ################################################################################## # begin cleaning pipe chain ########################### linelist &lt;- linelist_raw %&gt;% # standardize column name syntax janitor::clean_names() %&gt;% # manually re-name columns # NEW name # OLD name rename(date_infection = infection_date, date_hospitalisation = hosp_date, date_outcome = date_of_outcome) %&gt;% # remove column select(-c(row_num, merged_header, x25)) %&gt;% # fix incorrect values # old value # new value mutate(date_onset = recode(date_onset, &quot;15th April 2014&quot; = &quot;2014-04-15&quot;)) %&gt;% # correct the class of the columns mutate(across(contains(&quot;date&quot;), as.Date), generation = as.numeric(generation), age = as.numeric(age)) %&gt;% # create column: delay to hospitalisation mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% # clean values of hospital column mutate(hospital = recode(hospital, # OLD = NEW &quot;Mitylira Hopital&quot; = &quot;Military Hospital&quot;, &quot;Mitylira Hospital&quot; = &quot;Military Hospital&quot;, &quot;Military Hopital&quot; = &quot;Military Hospital&quot;, &quot;Port Hopital&quot; = &quot;Port Hospital&quot;, &quot;Central Hopital&quot; = &quot;Central Hospital&quot;, &quot;other&quot; = &quot;Other&quot;, &quot;St. Marks Maternity Hopital (SMMH)&quot; = &quot;St. Mark&#39;s Maternity Hospital (SMMH)&quot; )) %&gt;% mutate(hospital = replace_na(hospital, &quot;Missing&quot;)) %&gt;% # create age_years column (from age and age_unit) mutate(age_years = case_when( age_unit == &quot;years&quot; ~ age, age_unit == &quot;months&quot; ~ age/12, is.na(age_unit) ~ age, TRUE ~ NA_real_)) %&gt;% filter( # keep only rows where case_id is not missing !is.na(case_id), # also filter to keep only the second outbreak date_onset &gt; as.Date(&quot;2013-06-01&quot;) | (is.na(date_onset) &amp; !hospital %in% c(&quot;Hospital A&quot;, &quot;Hospital B&quot;))) %&gt;% mutate( # age categories: custom age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)), # age categories: 0 to 85 by 5s age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %&gt;% distinct() 5 Age pyramids Age pyramids can be useful to show patterns by age group. They can show gender, or the distribution of other characteristics. These tabs demonstrate how to produce age pyramids using: Fast &amp; easy: Using the apyramid package More flexible: Using ggplot() Having baseline demographics displayed in the background of the pyramid Using pyramid-style plots to show other types of data (e.g responses to Likert-style questions) 5.1 Overview Age/gender demographic pyramids in R are generally made with ggplot() by creating two barplots (one for each gender), converting ones values to negative values, and flipping the x and y axes to display the barplots vertically. Here we offer a quick approach through the apyramid package: More customizable code using the raw ggplot() commands How to combine case demographic data and compare with that of a baseline population (as shown above) Application of these methods to show other types of data (e.g. responses to Likert-style survey questions) 5.2 Preparation Preparation For this tab we use the linelist dataset that is cleaned in the Cleaning tab. To make a traditional age/sex demographic pyramid, the data must first be cleaned in the following ways: The gender column must be cleaned. Age should be in an age category column, and should be an of class Factor (with correctly ordered levels) Load packages First, load the packages required for this analysis: pacman::p_load(rio, # to import data here, # to locate files tidyverse, # to clean, handle, and plot the data (includes ggplot2 package) apyramid, # a package dedicated to creating age pyramids stringr) # working with strings for titles, captions, etc. Load the data linelist &lt;- rio::import(&quot;linelist_cleaned.csv&quot;) Check class of variables Ensure that the age variable is class Numeric, and check the class and order of levels of age_cat and age_cat5 class(linelist$age_years) ## [1] &quot;numeric&quot; class(linelist$age_cat) ## [1] &quot;factor&quot; class(linelist$age_cat5) ## [1] &quot;factor&quot; table(linelist$age_cat, useNA = &quot;always&quot;) ## ## 0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+ &lt;NA&gt; ## 1054 1153 957 889 1065 658 24 0 88 table(linelist$age_cat5, useNA = &quot;always&quot;) ## ## 0-4 5-9 10-14 15-19 20-24 25-29 30-34 35-39 40-44 45-49 50-54 55-59 60-64 ## 1054 1153 957 889 570 495 315 171 113 59 14 6 2 ## 65-69 70-74 75-79 80-84 85+ &lt;NA&gt; ## 2 0 0 0 0 88 5.3 apyramid package apyramid package The package apyramid allows you to quickly make an age pyramid. For more nuanced situations, see the tab on using ggplot() to make age pyramids. You can read more about the apyramid package in its Help page by entering ?age_pyramid in your R console. 5.3.1 Linelist data Linelist data Using the cleaned linelist dataset, we can create an age pyramid with just one simple command. If you need help cleaning your data, see the handbook page on Cleaning data (LINK). In this command: The data argument is set as the linelist dataframe The age_group argument is set to the name (in quotes) of the numeric category variable (in this case age_cat5) The split_by argument (bar colors) should be a binary column (in this case gender) apyramid::age_pyramid(data = linelist, age_group = &quot;age_cat5&quot;, split_by = &quot;gender&quot;) ## Warning: 281 missing rows were removed (88 values from `age_cat5` and 281 values ## from `gender`). When using agepyramid package, if the split_by column is binary (e.g. male/female, or yes/no), then the result will appear as a pyramid. However if there are more than two values in the split_by column (not including NA), the pyramid will appears as a faceted barplot with empty bars in the background indicating the range of the un-faceted data set for the age group. Values of split_by will appear as labels at top of each facet. For example below if the split_by variable is hospital. apyramid::age_pyramid(data = linelist, age_group = &quot;age_cat5&quot;, split_by = &quot;hospital&quot;, na.rm = FALSE) # show a bar for patients missing age, (note: this changes the pyramid into a faceted barplot) Missing values Rows missing values for the split_by or age_group columns, if coded as NA, will not trigger the faceting shown above. By default these rows will not be shown. However you can specify that they appear, in an adjacent barplot and as a separate age group at the top, by specifying na.rm = FALSE. apyramid::age_pyramid(data = linelist, age_group = &quot;age_cat5&quot;, split_by = &quot;gender&quot;, na.rm = FALSE) # show patients missing age or gender Proportions, colors, &amp; aesthetics By default, the bars display counts (not %), a dashed mid-line for each group is shown, and the colors are green/purple. Each of these parameters can all be adjusted, as shown below: You can also add additional ggplot() commands to the plot using the standard ggplot() + syntax, such as aesthetic themes and label adjustments: apyramid::age_pyramid(data = linelist, age_group = &quot;age_cat5&quot;, split_by = &quot;gender&quot;, proportional = TRUE, # show percents, not counts show_midpoint = FALSE, # remove bar mid-point line #pal = c(&quot;orange&quot;, &quot;purple&quot;) # can specify alt. colors here (but not labels, see below) )+ # additional ggplot commands theme_minimal()+ # simplify the background scale_fill_manual(values = c(&quot;orange&quot;, &quot;purple&quot;), # to specify colors AND labels labels = c(&quot;Male&quot;, &quot;Female&quot;))+ labs(y = &quot;Percent of all cases&quot;, # note that x and y labels are switched (see ggplot tab) x = &quot;Age categories&quot;, fill = &quot;Gender&quot;, caption = &quot;My data source and caption here&quot;, title = &quot;Title of my plot&quot;, subtitle = &quot;Subtitle with \\n a second line...&quot;)+ theme( legend.position = &quot;bottom&quot;, # move legend to bottom axis.text = element_text(size = 10, face = &quot;bold&quot;), # fonts/sizes, see ggplot tips page axis.title = element_text(size = 12, face = &quot;bold&quot;)) ## Warning: 281 missing rows were removed (88 values from `age_cat5` and 281 values ## from `gender`). ## Scale for &#39;fill&#39; is already present. Adding another scale for &#39;fill&#39;, which ## will replace the existing scale. 5.3.2 Aggregated data Aggregated data The examples above assume your data are in a linelist-like format, with one row per observation. If your data are already aggregated into counts by age category, you can still use the apyramid package, as shown below. Lets say that your dataset looks like this, with columns for age category, and male counts, female counts, and missing counts. (see the handbook page on Transforming data for tips) ## `summarise()` has grouped output by &#39;age_cat5&#39;. You can override using the `.groups` argument. # View the aggregated data DT::datatable(demo_agg, rownames = FALSE, filter=&quot;top&quot;, options = list(pageLength = 5, scrollX=T) ) ggplot() perfers data in long format, so first pivot the data to be long with the pivot_longer() function from dplyr. # pivot the aggregated data into long format demo_agg_long &lt;- demo_agg %&gt;% pivot_longer(c(f, m, missing_gender), # cols to elongate names_to = &quot;gender&quot;, # name for new col of categories values_to = &quot;counts&quot;) %&gt;% # name for new col of counts mutate(gender = na_if(gender, &quot;missing_gender&quot;)) # convert &quot;missing_gender&quot; to NA # View the aggregated data DT::datatable(demo_agg_long, rownames = FALSE, filter=&quot;top&quot;, options = list(pageLength = 5, scrollX=T) ) Then use the split_by and count arguments of age_pyramid() to specify the respective columns: apyramid::age_pyramid(data = demo_agg_long, age_group = &quot;age_cat5&quot;, split_by = &quot;gender&quot;, count = &quot;counts&quot;) # give the column name for the aggregated counts ## Warning: Removed 20 rows containing missing values (position_stack). ## Warning: Removed 19 rows containing missing values. Note in the above, that the factor order of m and f is different (pyramid reversed). To adjust the order you must re-define gender in the aggredated data as a Factor and order the levels as desired. 5.4 ggplot() ggplot() Using ggplot() to build your age pyramid allows for more flexibility, but requires more effort and understanding of how ggplot() works. It is also easier to accidentally make mistakes. apyramid uses ggplot() in the background (and accepts ggplot() commands added), but this page shows how to adjust or recreate a pyramid only using ggplot(), if you wish. 5.4.1 Constructing the plot Constructing the plot First, understand that to make such a pyramid using ggplot() the approach is to: Within the ggplot(), create two graphs by age category. Create one for each of the two grouping values (in this case gender). See filters applied to the data arguments in each geom_histogram() commands below. If using geom_histogram(), the graphs operate off the numeric column (e.g. age_years), whereas if using geom_barplot() the graphs operate from an ordered Factor (e.g. age_cat5). One graph will have positive count values, while the other will have its counts converted to negative values - this allows both graphs to be seen and compared against each other in the same plot. The command coord_flip() switches the X and Y axes, resulting in the graphs turning vertical and creating the pyramid. Lastly, the counts-axis labels must be specified so they appear as positive counts on both sides of the pyramid (despite the underlying values on one side being negative). A simple version of this, using geom_histogram(), is below: # begin ggplot ggplot(data = linelist, aes(x = age, fill = gender)) + # female histogram geom_histogram(data = filter(linelist, gender == &quot;f&quot;), breaks = seq(0,85,5), colour = &quot;white&quot;) + # male histogram (values converted to negative) geom_histogram(data = filter(linelist, gender == &quot;m&quot;), breaks = seq(0,85,5), aes(y=..count..*(-1)), colour = &quot;white&quot;) + # flip the X and Y axes coord_flip() + # adjust counts-axis scale scale_y_continuous(limits = c(-600, 900), breaks = seq(-600,900,100), labels = abs(seq(-600, 900, 100))) DANGER: If the limits of your counts axis are set too low, and a counts bar exceeds them, the bar will disappear entirely or be artificially shortened! Watch for this if analyzing data which is routinely updated. Prevent it by having your count-axis limits auto-adjust to your data, as below. There are many things you can change/add to this simple version, including: Auto adjust counts-axis count scale to your data (avoid errors discussed in warning below) Manually specify colors and legend labels # create dataset with proportion of total pyramid_data &lt;- linelist %&gt;% group_by(age_cat5, gender) %&gt;% summarize(counts = n()) %&gt;% ungroup() %&gt;% mutate(percent = round(100*(counts / sum(counts, na.rm=T)),1), percent = case_when( gender == &quot;f&quot; ~ percent, gender == &quot;m&quot; ~ -percent, TRUE ~ NA_real_)) ## `summarise()` has grouped output by &#39;age_cat5&#39;. You can override using the `.groups` argument. max_per &lt;- max(pyramid_data$percent, na.rm=T) min_per &lt;- min(pyramid_data$percent, na.rm=T) # begin ggplot ggplot()+ # default x-axis is age in years; # case data graph geom_bar(data = pyramid_data, stat = &quot;identity&quot;, aes(x = age_cat5, y = percent, fill = gender), # colour = &quot;white&quot;)+ # white around each bar # flip the X and Y axes to make pyramid vertical coord_flip()+ # adjust the axes scales (remember they are flipped now!) #scale_x_continuous(breaks = seq(0,100,5), labels = seq(0,100,5)) + scale_y_continuous(limits = c(min_per, max_per), breaks = seq(floor(min_per), ceiling(max_per), 2), labels = paste0(abs(seq(floor(min_per), ceiling(max_per), 2)), &quot;%&quot;))+ # designate colors and legend labels manually scale_fill_manual( values = c(&quot;f&quot; = &quot;orange&quot;, &quot;m&quot; = &quot;darkgreen&quot;), labels = c(&quot;Female&quot;, &quot;Male&quot;), ) + # label values (remember X and Y flipped now) labs( x = &quot;Age group&quot;, y = &quot;Percent of total&quot;, fill = NULL, caption = stringr::str_glue(&quot;Data are from linelist \\nn = {nrow(linelist)} (age or sex missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases) \\nData as of: {format(Sys.Date(), &#39;%d %b %Y&#39;)}&quot;)) + # optional aesthetic themes theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = &quot;black&quot;), plot.title = element_text(hjust = 0.5), plot.caption = element_text(hjust=0, size=11, face = &quot;italic&quot;)) + ggtitle(paste0(&quot;Age and gender of cases&quot;)) ## Warning: Removed 10 rows containing missing values (position_stack). 5.4.2 Compare to baseline Compare to baseline With the flexibility of ggplot(), you can have a second layer of bars in the background that represent the true population pyramid. This can provide a nice visualization to compare the observed counts with the baseline. Import and view the population data # import the population demographics data pop &lt;- rio::import(&quot;country_demographics.csv&quot;) # display the linelist data as a table DT::datatable(pop, rownames = FALSE, filter=&quot;top&quot;, options = list(pageLength = 10, scrollX=T) ) First some data management steps: Here we record the order of age categories that we want to appear. Due to some quirks the way the ggplot() is implemented, it is easiest to store these as a character vector and use them later in the plotting function. # record correct age cat levels age_levels &lt;- c(&quot;0-4&quot;,&quot;5-9&quot;, &quot;10-14&quot;, &quot;15-19&quot;, &quot;20-24&quot;, &quot;25-29&quot;,&quot;30-34&quot;, &quot;35-39&quot;, &quot;40-44&quot;, &quot;45-49&quot;, &quot;50-54&quot;, &quot;55-59&quot;, &quot;60-64&quot;, &quot;65-69&quot;, &quot;70-74&quot;, &quot;75-79&quot;, &quot;80-84&quot;, &quot;85+&quot;) Combine the population and case data through the dplyr function bind_rows(): First, ensure they have the exact same column names, age categories values, and gender values Make them have the same data structure: columns of age category, gender, counts, and percent of total Bind them together, one on-top of the other (bind_rows()) # create/transform populaton data, with percent of total ######################################################## pop_data &lt;- pivot_longer(pop, c(m, f), names_to = &quot;gender&quot;, values_to = &quot;counts&quot;) %&gt;% # pivot gender columns longer mutate(data = &quot;population&quot;, # add column designating data source percent = round(100*(counts / sum(counts, na.rm=T)),1), # calculate % of total percent = case_when( # if male, convert % to negative gender == &quot;f&quot; ~ percent, gender == &quot;m&quot; ~ -percent, TRUE ~ NA_real_)) Review the changed population dataset # display the linelist data as a table DT::datatable(pop_data, rownames = FALSE, filter=&quot;top&quot;, options = list(pageLength = 5, scrollX=T) ) Now implement the same for the case linelist. Slightly different because it begins with case-rows, not counts. # create case data by age/gender, with percent of total ####################################################### case_data &lt;- linelist %&gt;% group_by(age_cat5, gender) %&gt;% # aggregate linelist cases into age-gender groups summarize(counts = n()) %&gt;% # calculate counts per age-gender group ungroup() %&gt;% mutate(data = &quot;cases&quot;, # add column designating data source percent = round(100*(counts / sum(counts, na.rm=T)),1), # calculate % of total for age-gender groups percent = case_when( # convert % to negative if male gender == &quot;f&quot; ~ percent, gender == &quot;m&quot; ~ -percent, TRUE ~ NA_real_)) ## `summarise()` has grouped output by &#39;age_cat5&#39;. You can override using the `.groups` argument. Review the changed case dataset # display the linelist data as a table DT::datatable(case_data, rownames = FALSE, filter=&quot;top&quot;, options = list(pageLength = 5, scrollX=T) ) Now the two datasets are combined, one on top of the other (same column names) # combine case and population data (same column names, age_cat values, and gender values) pyramid_data &lt;- bind_rows(case_data, pop_data) Store the maximum and minimum percent values, used in the plotting funtion to define the extent of the plot (and not cut off any bars!) # Define extent of percent axis, used for plot limits max_per &lt;- max(pyramid_data$percent, na.rm=T) min_per &lt;- min(pyramid_data$percent, na.rm=T) Now the plot is made with ggplot(): One bar graph of population data (wider, more transparent bars) One bar graph of case data (small, more solid bars) # begin ggplot ############## ggplot()+ # default x-axis is age in years; # population data graph geom_bar(data = filter(pyramid_data, data == &quot;population&quot;), stat = &quot;identity&quot;, aes(x = age_cat5, y = percent, fill = gender), colour = &quot;black&quot;, # black color around bars alpha = 0.2, # more transparent width = 1)+ # full width # case data graph geom_bar(data = filter(pyramid_data, data == &quot;cases&quot;), stat = &quot;identity&quot;, # use % as given in data, not counting rows aes(x = age_cat5, # age categories as original X axis y = percent, # % as original Y-axis fill = gender), # fill of bars by gender colour = &quot;black&quot;, # black color around bars alpha = 1, # not transparent width = 0.3)+ # half width # flip the X and Y axes to make pyramid vertical coord_flip()+ # adjust axes order, scale, and labels (remember X and Y axes are flipped now) # manually ensure that age-axis is ordered correctly scale_x_discrete(limits = age_levels)+ # set percent-axis scale_y_continuous(limits = c(min_per, max_per), # min and max defined above breaks = seq(floor(min_per), ceiling(max_per), by = 2), # from min% to max% by 2 labels = paste0( # for the labels, paste together... abs(seq(floor(min_per), ceiling(max_per), by = 2)), # ...rounded absolute values of breaks... &quot;%&quot;))+ # ... with &quot;%&quot; # floor(), ceiling() round down and up # designate colors and legend labels manually scale_fill_manual( values = c(&quot;f&quot; = &quot;orange&quot;, # assign colors to values in the data &quot;m&quot; = &quot;darkgreen&quot;), labels = c(&quot;f&quot; = &quot;Female&quot;, &quot;m&quot;= &quot;Male&quot;), # change labels that appear in legend, note order ) + # plot labels, titles, caption labs( title = &quot;Case age and gender distribution,\\nas compared to baseline population&quot;, subtitle = &quot;&quot;, x = &quot;Age category&quot;, y = &quot;Percent of total&quot;, fill = NULL, caption = stringr::str_glue(&quot;Cases shown on top of country demographic baseline\\nCase data are from linelist, n = {nrow(linelist)}\\nAge or gender missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases\\nCase data as of: {format(max(linelist$date_onset, na.rm=T), &#39;%d %b %Y&#39;)}&quot;)) + # optional aesthetic themes theme( legend.position = &quot;bottom&quot;, # move legend to bottom panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = &quot;black&quot;), plot.title = element_text(hjust = 0), plot.caption = element_text(hjust=0, size=11, face = &quot;italic&quot;)) ## Warning: Removed 10 rows containing missing values (position_stack). 5.5 Likert scale Likert scale The techniques used to make a population pyramid with ggplot() can also be used to make plots of Likert-scale survey data. Import the data # import the likert survey response data likert_data &lt;- rio::import(&quot;likert_data.csv&quot;) Start with data that looks like this, with a categorical classification of each respondent (status) and their answers to 8 questions on a 4-point Likert-type scale (Very poor, Poor, Good, Very good). # display the linelist data as a table DT::datatable(likert_data, rownames = FALSE, filter=&quot;top&quot;, options = list(pageLength = 10, scrollX=T) ) First, some data management steps: Pivot the data longer Create new column direction depending on whether response was generally positive or negative Set the Factor level order for the status column and the Response column Store the max count value so limits of plot are appropriate melted &lt;- pivot_longer(likert_data, Q1:Q8, names_to = &quot;Question&quot;, values_to = &quot;Response&quot;) %&gt;% mutate(direction = case_when( Response %in% c(&quot;Poor&quot;,&quot;Very Poor&quot;) ~ &quot;Negative&quot;, Response %in% c(&quot;Good&quot;, &quot;Very Good&quot;) ~ &quot;Positive&quot;, TRUE ~ &quot;Unknown&quot;), status = factor(status, levels = rev(c( &quot;Senior&quot;, &quot;Intermediate&quot;, &quot;Junior&quot;))), Response = factor(Response, levels = c(&quot;Very Good&quot;, &quot;Good&quot;, &quot;Very Poor&quot;, &quot;Poor&quot;))) # must reverse Very Poor and Poor for ordering to work melted_max &lt;- melted %&gt;% group_by(status, Question) %&gt;% summarize(n = n()) ## `summarise()` has grouped output by &#39;status&#39;. You can override using the `.groups` argument. melted_max &lt;- max(melted_max$n, na.rm=T) Now make the plot: # make plot ggplot()+ # bar graph of the &quot;negative&quot; responses geom_bar(data = filter(melted, direction == &quot;Negative&quot;), aes(x = status, y=..count..*(-1), # counts inverted to negative fill = Response), color = &quot;black&quot;, closed = &quot;left&quot;, position = &quot;stack&quot;)+ # bar graph of the &quot;positive responses geom_bar(data = filter(melted, direction == &quot;Positive&quot;), aes(x = status, fill = Response), colour = &quot;black&quot;, closed = &quot;left&quot;, position = &quot;stack&quot;)+ # flip the X and Y axes coord_flip()+ # Black vertical line at 0 geom_hline(yintercept = 0, color = &quot;black&quot;, size=1)+ # convert labels to all positive numbers scale_y_continuous(limits = c(-ceiling(melted_max/10)*11, ceiling(melted_max/10)*10), # seq from neg to pos by 10, edges rounded outward to nearest 5 breaks = seq(-ceiling(melted_max/10)*10, ceiling(melted_max/10)*10, 10), labels = abs(unique(c(seq(-ceiling(melted_max/10)*10, 0, 10), seq(0, ceiling(melted_max/10)*10, 10))))) + # color scales manually assigned scale_fill_manual(values = c(&quot;Very Good&quot; = &quot;green4&quot;, # assigns colors &quot;Good&quot; = &quot;green3&quot;, &quot;Poor&quot; = &quot;yellow&quot;, &quot;Very Poor&quot; = &quot;red3&quot;), breaks = c(&quot;Very Good&quot;, &quot;Good&quot;, &quot;Poor&quot;, &quot;Very Poor&quot;))+ # orders the legend # facet the entire plot so each question is a sub-plot facet_wrap(~Question, ncol = 3)+ # labels, titles, caption labs(x = &quot;Respondent status&quot;, y = &quot;Number of responses&quot;, fill = &quot;&quot;)+ ggtitle(str_glue(&quot;Likert-style responses\\nn = {nrow(likert_data)}&quot;))+ # aesthetic settings theme_minimal()+ theme(axis.text = element_text(size = 12), axis.title = element_text(size = 14, face = &quot;bold&quot;), strip.text = element_text(size = 14, face = &quot;bold&quot;), # facet sub-titles plot.title = element_text(size = 20, face = &quot;bold&quot;), panel.background = element_rect(fill = NA, color = &quot;black&quot;)) # black box around each facet ## Warning: Ignoring unknown parameters: closed ## Warning: Ignoring unknown parameters: closed 5.6 Resources Resources This tab should stay with the name Resources. Links to other online tutorials or resources. "]]
